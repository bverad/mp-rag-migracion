def projectName="mp-rag-migracion"
def repodocker="mercadopublico"
def projectVersion="1.0.0"
def branch="main"
def sonarQube="http://192.168.2.166:9000"
def apache="192.168.2.166"
def nexus="192.168.2.166:5000"
def status
def testResults = [:]

pipeline {
	agent any
	parameters {
		booleanParam(name:'executeTests', defaultValue:true, description:'Ejecutar pruebas unitarias y de cobertura')
	}
	
	environment {
        DOCKER_USERNAME = credentials('user-docker-ait')  // ID de la credencial del nombre de usuario
        DOCKER_PASSWORD = credentials('pass-docker-ait')  // ID de la credencial de la contraseña
        ADMIN_CONF = credentials('admin.conf')
        PYTEST_ADDOPTS = "--html=reports/report.html --self-contained-html --cov=src --cov-report=html:reports/coverage --cov-report=term-missing"
        TEST_COVERAGE_THRESHOLD = "80"
    }
	
	stages {
		stage('init') {
		    steps {
		        script {
		            cleanWs()
                    echo "init ${projectName} pipeline"
		        }
            }
		}
		
		stage('git clone') {
		    steps {
		        script {
		            sshagent(['git']) {
                    echo "Git clone ${projectName} github"
                    sh "ls -la ~/.ssh/"
                    sh "git clone https://github.com/bverad/${projectName}.git"
                    sh "cd ${projectName}; git checkout ${branch};git rev-parse --verify HEAD"
                    sh "cd ${projectName}; git checkout ${branch};git pull"
                    sh "cd ${projectName}; ls -la"

		            }
		        }
            }
		}

		
		stage('build') {
			steps {
			    script{
			        echo "building app"
                    //sh "mvn clean install"
                    sh "cd ${projectName}; docker build -t ${projectName} ."
			    }

			}
		}
		
		stage('test'){
			when {
				expression {
					params.executeTests
				}
			}
			steps {
				script {
					echo "Ejecutando pruebas unitarias y de cobertura"
					try {
						// Crear directorio para reportes
						sh "mkdir -p ${projectName}/reports"
						
						// Crear archivo .env temporal para pruebas
						sh """echo 'OPENAI_API_KEY=sk-test-mock-key-123456789
OPENAI_MODEL=gpt-3.5-turbo
OPENAI_TEMPERATURE=0.7
TESTING=true
DEBUG=true
PORT=5000
USERNAME=test_user
PASSWORD=test_password
EMPRESA_ID=1
APP_ENV=testing
PYTHONPATH=/app
LOG_LEVEL=DEBUG
CACHE_TTL=3600
MAX_TOKENS=2000
CHUNK_SIZE=1000
CHUNK_OVERLAP=200
MODEL_NAME=gpt-3.5-turbo
EMBEDDING_MODEL=text-embedding-ada-002' > ${projectName}/.env"""
						
						// Asegurar permisos de ejecución en el script de tests
						sh "chmod +x ${projectName}/scripts/run_tests.sh"
						
						// Ejecutar pruebas dentro del contenedor
						def testOutput = sh(
							script: """
								docker run --rm \
								  -v /var/lib/jenkins/workspace/${projectName}/${projectName}:/app \
								  ${projectName}:latest ./scripts/run_tests.sh
							""",
							returnStdout: true
						)
						
						// Extraer porcentaje de cobertura directamente del output de run_tests.sh
						def coverageMatch = (testOutput =~ /TOTAL.*?(\d+)%/)
						if (coverageMatch) {
							testResults.coverage = coverageMatch[0][1].toInteger()
							if (testResults.coverage < env.TEST_COVERAGE_THRESHOLD.toInteger()) {
								error "Cobertura de código (${testResults.coverage}%) por debajo del umbral requerido (${env.TEST_COVERAGE_THRESHOLD}%)"
							}
						} else {
							error "No se pudo obtener el porcentaje de cobertura del reporte"
						}
						
						// Verificar que el directorio de reportes existe
						if (!fileExists("${projectName}/reports")) {
							error "El directorio de reportes no existe"
						}
						
						// Archivar reportes
						archiveArtifacts artifacts: "${projectName}/reports/**/*", fingerprint: true
						
						// Publicar reporte HTML de pruebas
						publishHTML(target: [
							allowMissing: false,
							alwaysLinkToLastBuild: true,
							keepAll: true,
							reportDir: "${projectName}/reports",
							reportFiles: 'report.html',
							reportName: 'Test Report'
						])
						
						// Publicar reporte de cobertura
						publishHTML(target: [
							allowMissing: false,
							alwaysLinkToLastBuild: true,
							keepAll: true,
							reportDir: "${projectName}/reports/coverage",
							reportFiles: 'index.html',
							reportName: 'Coverage Report'
						])
					} catch (Exception e) {
						testResults.failed = true
						testResults.error = e.getMessage()
						error "Error en las pruebas: ${e.getMessage()}"
					} finally {
						// Limpiar archivo .env temporal
						sh "rm -f ${projectName}/.env"
					}
				}

				echo "scanning code"
				script {      
					// requires SonarQube Scanner 2.8+
					scannerHome = tool 'SonarQubeScanner'
					withSonarQubeEnv('SonarQubeAIT') {
						sh "${scannerHome}/bin/sonar-scanner -Dsonar.sources=${projectName}/ -Dsonar.host.url=${sonarQube} -Dsonar.projectKey=${projectName} -Dsonar.projectName=${projectName} -Dsonar.projectVersion=${projectVersion} -Dsonar.language=js"
					}

					echo "trivy evaluation"
					sh "trivy fs --format template --template '@/home/jenkins/templates/html.tpl' --ignore-unfixed --severity MEDIUM,HIGH,CRITICAL --exit-code 0 -o trivy-report.html ./"
				}
			}
		}
		
        stage('docker push') {
			steps {
			    script{
			        echo "docker push nexus-ait"
			        sh """
                    echo \$DOCKER_PASSWORD | docker login -u \$DOCKER_USERNAME --password-stdin
                    """
                    sh "docker tag ${projectName}:latest mpulgarf/${repodocker}-${projectName}:latest"
                    sh "docker push mpulgarf/${repodocker}-${projectName}:latest"
			    }

			}
		}
		
		stage('kubernetes deploy') {
			steps {
			    script{
			        echo "despliegue imagen kubernetes-ait"
			        sh "rm -f /var/lib/jenkins/.kube/config"
			        sh "cp -f /home/jenkins/config /var/lib/jenkins/.kube/config"			        
			        sh "export KUBECONFIG=~/.kube/config"
                    sh "kubectl apply -f ${projectName}/k8s/deployment.yaml --validate=false"
                    sh "kubectl rollout restart deployment ${projectName}-deployment"
			    }

			}
		}
		
	}
	
	post {
   		success {
            echo "Success"
            script{
                status = "success"
                echo "final status ${status}"

            }
		}
		
		failure {
		    echo "Failure"
		    script {
		        status = "failure"
		    }
		}
		
		aborted {
		    echo "Aborted"
		    script {
		        status = "aborted"
		    }
		}

        cleanup {
           echo "Sending slack notification"
           script {
                echo "final status ${status}"
                def blocks = getBlockSlackMessage(projectName, projectVersion, status)
                
                // Agregar resultados de pruebas al mensaje de Slack si existen
                if (testResults) {
                    def testBlock = [
                        "type": "section",
                        "text": [
                            "type": "mrkdwn",
                            "text": "*Test Results*\n" +
                                   "${testResults.failed ? '❌ Tests failed: ' + testResults.error : '✅ All tests passed'}\n" +
                                   "Coverage: ${testResults.coverage ?: 'N/A'}%"
                        ]
                    ]
                    blocks.add(blocks.size() - 1, testBlock)
                }
                
                def slackResponse = slackSend(color:"${status.equals('success') ? 'good' : 'danger'}", blocks: blocks)
                
                // Adjuntar reportes al hilo de Slack
                if (fileExists("${projectName}/reports/report.html")) {
                    slackUploadFile(channel: slackResponse.threadId, filePath: "${projectName}/reports/report.html", initialComment: "Test Report")
                }
                if (fileExists("${projectName}/reports/coverage/index.html")) {
                    slackUploadFile(channel: slackResponse.threadId, filePath: "${projectName}/reports/coverage/index.html", initialComment: "Coverage Report")
                }
                slackUploadFile(channel: slackResponse.threadId, filePath: "trivy-report.html", initialComment: "Trivy report.")

                echo "Cleaning workspace"
                cleanWs()

            }
        }
	}
	
}

def getBlockSlackMessage(projectName, projectVersion, status){
    blocks = [
        [
            "type": "header",
            "text": [
                "type": "plain_text",
                "text": "Building application ${projectName}:${projectVersion} ${status}",
                "emoji": true
            ]
        ],
        [
            "type": "divider"
        ],
        [
            "type": "section",
            "text": [
                "type": "mrkdwn",
                "text": "Details of building in the next link :ghost: *if you want* you can see the results in Jenkins. <${env.BUILD_URL}|Open>"
            ],

            "fields": [
                [
                    "type": "mrkdwn",
                    "text": "*Job name*"
                ],
                [
                    "type": "plain_text",
                    "text": "${env.JOB_NAME}"
                ],
                [
                    "type": "mrkdwn",
                    "text": "*Build URL*"
                ],
                [
                    "type": "plain_text",
                    "text": "${env.BUILD_URL}"
                ],
                [
                    "type": "mrkdwn",
                    "text": "*Build number*"
                ],
                [
                    "type": "plain_text",
                    "text": "${env.BUILD_NUMBER}"
                ],
                [
                    "type": "mrkdwn",
                    "text": "*Build display name*"
                ],
                [
                    "type": "plain_text",
                    "text": "${env.BUILD_DISPLAY_NAME}"
                ],
                [
                    "type": "mrkdwn",
                    "text": "*Branch*"
                ],
                [
                    "type": "plain_text",
                    "text": "${env.GIT_BRANCH}"
                ]
            ]
        ],
        [
            "type": "header",
            "text": [
                "type": "plain_text",
                "text": "Reports",
                "emoji": true
            ]
        ],
        [
            "type": "divider"
        ],
        [
            "type": "section",
            "text": [
                "type": "mrkdwn",
                "text": "*SonarQube*"
            ],
            "accessory": [
                "type": "button",
                "text": [
                    "type": "plain_text",
                    "text": "Click Me",
                    "emoji": true
                ],
                "value": "click_me_123",
                "url": "http://192.168.2.166:9000/dashboard?id=${projectName}",
                "action_id": "button-action"
            ]
        ]
    ]

    return blocks;
}
